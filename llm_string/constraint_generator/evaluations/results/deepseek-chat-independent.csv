sample_id,Name,NL description,NL negation,SMT-LIB2,SMT-LIB2 negation,Functions,Functions negation,SMT-LIB2 correct,SMT-LIB2 negation correct,Functions correct,Functions negation correct
01,Name,"1. The name shall only contain letters a-z, letters A-Z and space characters.

2. The name shall contain at least one space character.

3. The name shall not end with a space character.

4. The name shall not start with a space character.

5. The first character in the name shall be capitalized.

6. Any character in the name following a space character shall be capitalized.","1. The name shall contain at least one character that is neither a letter a-z, nor a letter A-Z, nor a space.

2. The name shall contain no space character.

3. The name shall end with a space character.

4. The name shall start with a space character.

5. The first character in the name shall not be capitalized.

6. In the name, there shall be some characters following a space character which are not capitalized.","1. (str.in.re s (re.++ (re.* (re.union (re.range ""a"" ""z"") (re.range ""A"" ""Z"") (str.to.re "" ""))) (re.* (re.union (re.range ""a"" ""z"") (re.range ""A"" ""Z"") (str.to.re "" "")))))

2. (str.contains s "" "")

3. (not (= (str.at s (- (str.len s) 1)) "" ""))

4. (not (= (str.at s 0) "" ""))

5. (and (>= (str.to_code (str.at s 0)) (str.to_code ""A"")) (<= (str.to_code (str.at s 0)) (str.to_code ""Z"")))

6. (str.in.re s (re.++ (re.* (re.union (re.range ""a"" ""z"") (re.range ""A"" ""Z""))) (re.* (re.++ (str.to.re "" "") (re.range ""A"" ""Z"")))))","1. (str.in.re s (re.++ (re.* (re.union (re.range ""a"" ""z"") (re.range ""A"" ""Z"") (str.to.re "" ""))) (re.comp (re.union (re.range ""a"" ""z"") (re.range ""A"" ""Z"") (str.to.re "" ""))) (re.* re.allchar)))

2. (not (str.contains s "" ""))

3. (str.suffixof "" "" s)

4. (= (str.at s 0) "" "")

5. (not (and (>= (str.to_code (str.at s 0)) 65) (<= (str.to_code (str.at s 0)) 90)))

6. (str.in.re s (re.++ (re.* re.allchar) (str.to.re "" "") (re.+ (re.range ""a"" ""z"")) (re.* re.allchar)))","[""def constraint1(s: str) -> bool:\n    ''' \n    Check if the name shall only contain letters a-z, letters A-Z and space characters.\n    \n    Args:\n    s (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string contains only letters and spaces, False otherwise.\n    '''\n    for char in s:\n        if not (char.isalpha() or char == ' '):\n            return False\n    return True"", ""def constraint2(s: str) -> bool:\n    ''' Check if the name shall contain at least one space character.'''\n    return ' ' in s"", ""def constraint3(s: str) -> bool:\n    ''' Check if the name shall not end with a space character.'''\n    return not s.endswith(' ')"", ""def constraint4(s: str) -> bool:\n    ''' Check if the name shall not start with a space character.'''\n    return not s.startswith(' ')"", ""def constraint5(s: str) -> bool:\n    ''' Check if the first character in the string is capitalized.'''\n    if len(s) == 0:\n        return False  # If the string is empty, return False\n    return s[0].isupper()"", ""def constraint6(s: str) -> bool:\n    ''' Check if any character in the string following a space character is capitalized.'''\n    for i in range(len(s) - 1):\n        if s[i] == ' ' and s[i+1].isupper():\n            return True\n    return False""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the name contains at least one character that is neither a letter a-z, nor a letter A-Z, nor a space.'''\n    for char in s:\n        if not char.isalpha() and char != ' ':\n            return True\n    return False"", ""def constraint2(s: str) -> bool:\n    ''' Check if The name shall contain no space character.'''\n    return ' ' not in s"", ""def constraint3(s: str) -> bool:\n    '''Check if the name shall end with a space character.'''\n    return s.endswith(' ')"", ""def constraint4(s: str) -> bool:\n    '''Check if the name shall start with a space character.'''\n    return s.startswith(' ')"", ""def constraint5(s: str) -> bool:\n    '''Check if the first character in the string is not capitalized.'''\n    if not s:  # If the string is empty, return True (or False, depending on your use case)\n        return True\n    return not s[0].isupper()  # Return True if the first character is not uppercase"", ""def constraint6(s: str) -> bool:\n    ''' Check if in the name, there are some characters following a space character which are not capitalized.'''\n    for i in range(len(s) - 1):\n        if s[i] == ' ' and s[i + 1].islower():\n            return True\n    return False""]","[True, True, True, True, True, True]","[True, True, True, True, True, True]","[True, True, True, True, True, True]","[True, True, True, True, True, True]"
02,Email,"1. The email shall not contain a space character.

2. The email shall not start with a @ character.

3. The email shall have exactly one @ character.

4. The email shall include a dot character (.) after the @ character but before the end.

5. The final character of the email shall not be a dot character (.).

6. The email shall not contain the word ""manager"".","1. The email shall contain a space character.

2. The email shall start with a @ character.

3. The email shall have either no @ characters or more than one @ character.

4. If the email contains a @ character and there shall not include any dot characters (.) after the @ character and before the end.

5. The final character of the email shall be a dot character (.).

6. The email shall contain the word ""manager"".","1. (not (str.contains s "" ""))

2. (not (= (str.at s 0) ""@""))

3. (and (str.contains s ""@"") (not (str.in.re s (re.++ (re.* re.allchar) (str.to.re ""@"") (re.* re.allchar) (str.to.re ""@"") (re.* re.allchar)))))

4. (let ((at_pos (str.indexof s ""@"" 0))) (and (>= at_pos 0) (str.contains (str.substr s (+ at_pos 1) (- (str.len s) (+ at_pos 1))) ""."")))

5. (not (= (str.at s (- (str.len s) 1)) "".""))

6. (not (str.contains s ""manager""))","1. (str.contains s "" "")

2. (= (str.at s 0) ""@"")

3. (or (not (str.contains s ""@"")) (str.in.re s (re.++ (re.* re.allchar) (str.to.re ""@"") (re.* re.allchar) (str.to.re ""@"") (re.* re.allchar))))

4. (=> (str.contains s ""@"") (not (str.contains (str.substr s (+ (str.indexof s ""@"") 1) (- (str.len s) (+ (str.indexof s ""@"") 1))) ""."")))

5. (= (str.at s (- (str.len s) 1)) ""."")

6. (str.contains s ""manager"")","[""def constraint1(s: str) -> bool:\n    ''' Check if the email shall not contain a space character.'''\n    return ' ' not in s"", ""def constraint2(s: str) -> bool:\n    ''' Check if the email shall not start with a @ character.'''\n    return not s.startswith('@')"", ""def constraint3(s: str) -> bool:\n    ''' Check if the email shall have exactly one @ character.'''\n    return s.count('@') == 1"", ""def constraint4(s: str) -> bool:\n    ''' \n    Check if the email includes a dot character (.) after the @ character but before the end.\n    \n    Args:\n    s (str): The email address to check.\n    \n    Returns:\n    bool: True if the condition is met, False otherwise.\n    '''\n    at_index = s.find('@')\n    \n    # If '@' is not found or it's the last character, return False\n    if at_index == -1 or at_index == len(s) - 1:\n        return False\n    \n    # Check if there is a '.' after '@' and before the end\n    dot_index = s.find('.', at_index + 1)\n    \n    # If '.' is found and it's not the last character, return True\n    return dot_index != -1 and dot_index < len(s) - 1"", ""def constraint5(s: str) -> bool:\n    ''' Check if the final character of the email shall not be a dot character (.).'''\n    if not s:  # Check if the string is empty\n        return False  # An empty string doesn't have a final character, so return False\n    return s[-1] != '.'  # Return True if the last character is not a dot, otherwise False"", 'def constraint6(s: str) -> bool:\n    \'\'\' Check if The email shall not contain the word ""manager"".\'\'\'\n    return ""manager"" not in s.lower()']","[""def constraint1(s: str) -> bool:\n    '''Check if the email contains a space character.'''\n    return ' ' in s"", ""def constraint2(s: str) -> bool:\n    ''' Check if the email shall start with a @ character.'''\n    return s.startswith('@')"", ""def constraint3(s: str) -> bool:\n    ''' \n    Check if the email shall have either no @ characters or more than one @ character.\n    \n    Args:\n        s (str): The email string to be checked.\n        \n    Returns:\n        bool: True if the email has either no @ characters or more than one @ character, False otherwise.\n    '''\n    count = s.count('@')\n    return count == 0 or count > 1"", ""def constraint4(s: str) -> bool:\n    # Check if there is exactly one '@' character in the string\n    if s.count('@') != 1:\n        return False\n    \n    # Split the string into local part and domain part\n    local_part, domain_part = s.split('@')\n    \n    # Check if there are any '.' characters in the domain part\n    if '.' in domain_part:\n        return False\n    \n    return True"", ""def constraint5(s: str) -> bool:\n    ''' Check if the final character of the email shall be a dot character (.).'''\n    return s.endswith('.')"", 'def constraint6(s: str) -> bool:\n    \'\'\' Check if the email shall contain the word ""manager"".\'\'\'\n    return ""manager"" in s.lower()']","[True, True, True, True, True, True]","[True, True, True, True, True, True]","[True, True, True, True, True, True]","[True, True, True, True, True, True]"
03,Password,"1. The password shall be at least 4 characters long.

2. The password shall contain one of the following characters: !, #, $.

3. The password shall contain at least one upper case characters.

4. The password shall contain at least one lower case characters.

5. The password shall contain at least one number.","1. The password shall contain less than 4 characters.

2. The password shall not contain any of the following characters: !, #, $.

3. The password shall not contain any upper case characters.

4. The password shall not contain any lower case characters.

5. The password shall not contain any numbers.","1. (>= (str.len s) 4)

2. (or (str.contains s ""!"") (str.contains s ""#"") (str.contains s ""$""))

3. (str.in.re s (re.++ (re.* re.allchar) (re.range ""A"" ""Z"") (re.* re.allchar)))

4. (str.in.re s (re.++ (re.* re.allchar) (re.range ""a"" ""z"") (re.* re.allchar)))

","1. (< (str.len s) 4)

2. (and (not (str.contains s ""!"")) (not (str.contains s ""#"")) (not (str.contains s ""$"")))

3. (not (str.in.re s (re.++ (re.* re.allchar) (re.range ""A"" ""Z"") (re.* re.allchar))))

4. (not (str.in.re s (re.range ""a"" ""z"")))

5. (not (str.in.re s (re.++ (re.* re.allchar) (re.range ""0"" ""9"") (re.* re.allchar))))","[""def constraint1(s: str) -> bool:\n    ''' Check if the password is at least 4 characters long.'''\n    return len(s) >= 4"", ""def constraint2(s: str) -> bool:\n    ''' Check if the password contains one of the following characters: !, #, $.'''\n    special_chars = {'!', '#', '$'}\n    return any(char in special_chars for char in s)"", ""def constraint3(s: str) -> bool:\n    ''' Check if the password contains at least one uppercase character.'''\n    for char in s:\n        if char.isupper():\n            return True\n    return False"", ""def constraint4(s: str) -> bool:\n    ''' Check if the password shall contain at least one lowercase character.'''\n    for char in s:\n        if char.islower():\n            return True\n    return False"", ""def constraint5(s: str) -> bool:\n    '''Check if the password contains at least one number.'''\n    return any(char.isdigit() for char in s)""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the password contains less than 4 characters.'''\n    return len(s) < 4"", ""def constraint2(s: str) -> bool:\n    ''' \n    Check if the password shall not contain any of the following characters: !, #, $.\n    \n    Args:\n    s (str): The password string to be checked.\n    \n    Returns:\n    bool: True if the password does not contain any forbidden characters, False otherwise.\n    '''\n    forbidden_chars = {'!', '#', '$'}\n    \n    # Check if any forbidden character is in the string\n    for char in forbidden_chars:\n        if char in s:\n            return False\n    \n    return True"", ""def constraint3(s: str) -> bool:\n    ''' Check if the password shall not contain any upper case characters.'''\n    return not any(char.isupper() for char in s)"", ""def constraint4(s: str) -> bool:\n    ''' Check if the password shall not contain any lowercase characters.'''\n    for char in s:\n        if char.islower():\n            return False\n    return True"", ""def constraint5(s: str) -> bool:\n    ''' Check if the password shall not contain any numbers.'''\n    for char in s:\n        if char.isdigit():\n            return False\n    return True""]","[True, True, True, True, False]","[True, True, True, True, True]","[True, True, True, True, True]","[True, True, True, True, True]"
04,Url,"1. The url shall start with either http:// or https://.

2. The url shall not contain any spaces.

3. The url shall contain at least one dot character (.).","1. The url shall not start with http://, nor with https://.

2. The url shall contain at least one space.

3. The url shall not contain any dot character (.).","1. (or (str.prefixof ""http://"" s) (str.prefixof ""https://"" s))

2. (not (str.contains s "" ""))

3. (str.contains s ""."")","1. (and (not (str.prefixof ""http://"" s)) (not (str.prefixof ""https://"" s)))

2. (str.contains s "" "")

3. (not (str.contains s "".""))","[""def constraint1(s: str) -> bool:\n    '''Check if the URL starts with either http:// or https://.'''\n    return s.startswith('http://') or s.startswith('https://')"", ""def constraint2(s: str) -> bool:\n    ''' Check if the URL shall not contain any spaces.'''\n    return ' ' not in s"", ""def constraint3(s: str) -> bool:\n    ''' Check if the URL contains at least one dot character (.).'''\n    return '.' in s""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the URL does not start with http://, nor with https://.'''\n    return not (s.startswith('http://') or s.startswith('https://'))"", ""def constraint2(s: str) -> bool:\n    ''' Check if the URL contains at least one space.'''\n    return ' ' in s"", ""def constraint3(s: str) -> bool:\n    ''' Check if the URL shall not contain any dot character (.).'''\n    return '.' not in s""]","[True, True, True]","[True, True, True]","[True, True, True]","[True, True, True]"
05,Date,"1. The date shall contain two hyphens.

2. If there is at least one hyphen, the part before the hyphen shall be a number between 0 and 2025.

3. If there are at least two hyphens, the part after the first hyphen but before the second hyphen shall be a number between 1 and 12.

4. If there are at least two hyphen, The part after the second hyphen shall be a number between 1 and 31.","1. The date shall contain either no hyphens, one hyphen or more than two hyphens.

2. There must be at least one hyphen and the part before the hyphen shall not be a number between 0 and 2025.

3. There must be at least two hyphens and the part after the first hyphen but before the second hyphen shall not be a number between 1 and 12.

4. There must be at least two hyphens an d the part after the second hyphen shall not be a number between 1 and 31.","1. (= (str.len (str.replace_all s ""-"" """")) (- (str.len s) 2))

2. (=> (s.contains s ""-"") (and (>= (s.to.int (s.subs s 0 (s.indexof s ""-"" 0))) 0) (<= (s.to.int (s.subs s 0 (s.indexof s ""-"" 0))) 2025)))

3. (let ((first_hyphen (str.indexof s ""-"" 0)) (let ((second_hyphen (str.indexof s ""-"" (+ first_hyphen 1)))) (=> (and (>= first_hyphen 0) (>= second_hyphen 0)) (let ((substring (str.substr s (+ first_hyphen 1) (- second_hyphen first_hyphen 1)))) (and (str.in.re substring (re.++ (re.range ""0"" ""9"") (re.* (re.range ""0"" ""9"")))) (let ((num (str.to.int substring))) (and (>= num 1) (<= num 12))))))

4. (=> (and (>= (str.indexof s ""-"" 0) 0) (>= (str.indexof s ""-"" (+ (str.indexof s ""-"" 0) 1)) 0)) (let ((second_hyphen_pos (str.indexof s ""-"" (+ (str.indexof s ""-"" 0) 1)))) (let ((after_second_hyphen (str.substr s (+ second_hyphen_pos 1) (- (str.len s) (+ second_hyphen_pos 1))))) (and (str.in_re after_second_hyphen (re.++ (re.range ""0"" ""9"") (re.* (re.range ""0"" ""9"")))) (<= 1 (str.to_int after_second_hyphen)) (<= (str.to_int after_second_hyphen) 31))))","1. (or (= (str.indexof s ""-"" 0) (- 1)) (= (str.indexof s ""-"" (+ (str.indexof s ""-"" 0) 1)) (- 1)) (> (str.indexof s ""-"" (+ (str.indexof s ""-"" (+ (str.indexof s ""-"" 0) 1)) 1)) (- 1)))

2. (and (str.contains s ""-"") (let ((prefix (str.substr s 0 (str.indexof s ""-"" 0)))) (or (not (str.is_digit prefix)) (or (< (str.to_int prefix) 0) (> (str.to_int prefix) 2025))))



","[""def constraint1(s: str) -> bool:\n    ''' Check if the date shall contain two hyphens.'''\n    return s.count('-') == 2"", ""def constraint2(s: str) -> bool:\n    # Check if there is at least one hyphen in the string\n    if '-' in s:\n        # Split the string into two parts\n        before_hyphen, after_hyphen = s.split('-', 1)\n        \n        # Check if the part before the hyphen is a number\n        if before_hyphen.isdigit():\n            number = int(before_hyphen)\n            # Check if the number is between 0 and 2025 (inclusive)\n            return 0 <= number <= 2025\n        else:\n            # If it's not a number, return False\n            return False\n    else:\n        # If there is no hyphen, return True (since the condition is about the presence of a hyphen)\n        return True"", ""def constraint3(s: str) -> bool:\n    # Split the string by hyphens\n    parts = s.split('-')\n    \n    # Check if there are at least two hyphens\n    if len(parts) < 3:\n        return False\n    \n    # Extract the part between the first and second hyphen\n    middle_part = parts[1]\n    \n    # Check if the middle part is a number between 1 and 12\n    try:\n        num = int(middle_part)\n        return 1 <= num <= 12\n    except ValueError:\n        return False"", ""def constraint4(s: str) -> bool:\n    # Split the string by hyphens\n    parts = s.split('-')\n    \n    # Check if there are at least two hyphens\n    if len(parts) < 3:\n        return False\n    \n    # Get the part after the second hyphen\n    number_part = parts[2]\n    \n    # Check if the part is a number and is between 1 and 31\n    try:\n        number = int(number_part)\n        return 1 <= number <= 31\n    except ValueError:\n        return False""]","[""def constraint1(s: str) -> bool:\n    ''' \n    Check if the date shall contain either no hyphens, one hyphen or more than two hyphens.\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string contains either no hyphens, one hyphen, or more than two hyphens. False otherwise.\n    '''\n    count = s.count('-')\n    return count == 0 or count == 1 or count > 2"", ""def constraint2(s: str) -> bool:\n    # Check if there is at least one hyphen in the string\n    if '-' not in s:\n        return False\n    \n    # Split the string into two parts using the hyphen\n    before_hyphen, after_hyphen = s.split('-', 1)\n    \n    # Check if the part before the hyphen is a number\n    if before_hyphen.isdigit():\n        number = int(before_hyphen)\n        # Check if the number is between 0 and 2025 (inclusive)\n        if 0 <= number <= 2025:\n            return False\n    \n    # If all checks pass, return True\n    return True"", ""def constraint3(s: str) -> bool:\n    # Check if there are at least two hyphens in the string\n    if s.count('-') < 2:\n        return False\n    \n    # Find the positions of the first and second hyphens\n    first_hyphen_index = s.find('-')\n    second_hyphen_index = s.find('-', first_hyphen_index + 1)\n    \n    # Extract the substring between the first and second hyphens\n    substring = s[first_hyphen_index + 1:second_hyphen_index]\n    \n    # Check if the substring is a number between 1 and 12\n    if substring.isdigit():\n        num = int(substring)\n        if 1 <= num <= 12:\n            return False\n    \n    # If all checks pass, return True\n    return True"", ""def constraint4(s: str) -> bool:\n    # Split the string by hyphens\n    parts = s.split('-')\n    \n    # Check if there are at least two hyphens\n    if len(parts) < 3:\n        return False\n    \n    # Get the part after the second hyphen\n    after_second_hyphen = parts[2]\n    \n    # Check if the part after the second hyphen is a number between 1 and 31\n    try:\n        num = int(after_second_hyphen)\n        if 1 <= num <= 31:\n            return False\n    except ValueError:\n        # If it's not a number, it's fine\n        pass\n    \n    # If all checks pass, return True\n    return True""]","[False, False, False, False]","[True, False, False, False]","[True, True, True, True]","[True, True, True, True]"
06,IBAN,"1. The length of the bank number shall be 22.

2. The bank number shall start with 1210.

3. The bank number shall have at least 6 characters, and the fifth and sixth characters shall both be 0.","1. The length of the bank account shall not be 22.

2. The bank number shall not start with 1210.

3. The bank number shall either have less than 6 characters, or either the fifth or sixth character shall not be 0.
","1. (= (str.len s) 22)

2. (= (str.substr s 0 4) ""1210"")

3. (and (>= (str.len s) 6) (= (str.at s 4) ""0"") (= (str.at s 5) ""0""))","1. (not (= (str.len s) 22))

2. (not (= (str.substr s 0 4) ""1210""))

3. (or (< (str.len s) 6) (not (= (str.at s 4) ""0"")) (not (= (str.at s 5) ""0"")))","[""def constraint1(s: str) -> bool:\n    ''' Check if the length of the bank number shall be 22.'''\n    return len(s) == 22"", 'def constraint2(s: str) -> bool:\n    \'\'\'Check if the bank number shall start with 1210.\'\'\'\n    return s.startswith(""1210"")', ""def constraint3(s: str) -> bool:\n    ''' \n    Check if the bank number shall have at least 6 characters, \n    and the fifth and sixth characters shall both be 0.\n    \n    Args:\n    s (str): The bank number to check.\n    \n    Returns:\n    bool: True if the bank number meets the criteria, False otherwise.\n    '''\n    # Check if the length is at least 6 characters\n    if len(s) < 6:\n        return False\n    \n    # Check if the fifth and sixth characters are both '0'\n    if s[4] == '0' and s[5] == '0':\n        return True\n    else:\n        return False""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the length of the bank account shall not be 22.'''\n    return len(s) != 22"", 'def constraint2(s: str) -> bool:\n    \'\'\'Check if the bank number shall not start with 1210.\'\'\'\n    return not s.startswith(""1210"")', ""def constraint3(s: str) -> bool:\n    ''' \n    Check if the bank number shall either have less than 6 characters, \n    or either the fifth or sixth character shall not be 0.\n    \n    Args:\n    s (str): The bank number as a string.\n    \n    Returns:\n    bool: True if the condition is met, False otherwise.\n    '''\n    if len(s) < 6:\n        return True\n    else:\n        # Check if the fifth or sixth character is not '0'\n        return s[4] != '0' or s[5] != '0'""]","[True, True, True]","[True, True, True]","[True, True, True]","[True, True, True]"
07,ISBN,"1. The ISBN shall only contain numbers (0-9), the letter X, or hyphens.

2. The last character of the ISBN shall either be a number (0-9) or the letter X.

3. The ISBN shall contain exactly 10 characters, excluding hyphens.

4. The ISBN shall not start with a hyphen.

5. Hyphens shall not occur consecutively in the ISBN.

6. The ISBN shall contain at most 3 hyphens.","1. The ISBN shall contain at least one character that is neither a number (0-9), nor the letter X, nor a hyphen.

2. The last character of the ISBN shall be neither a number (0-9), nor the letter X.

3. Without counting hyphens, the ISBN shall contain less than or more than 10 characters.

4. The ISBN shall start with a hyphen.

5. The ISBN shall contain two consecutive hyphens.

6. The ISBN shall contain more than 3 hyphens.","1. (str.in.re s (re.++ (re.* (re.union (re.range ""0"" ""9"") (str.to.re ""X"") (str.to.re ""-"")))))

2. (or (and (>= (str.to_code (str.at s (- (str.len s) 1))) 48) (<= (str.to_code (str.at s (- (str.len s) 1))) 57)) (= (str.at s (- (str.len s) 1)) ""X""))

3. (= (str.len (str.replace_all s ""-"" """")) 10)

4. (not (= (str.at s 0) ""-""))

5. (forall ((i Int)) (=> (and (>= i 0) (< i (- (str.len s) 1))) (not (and (= (str.at s i) ""-"") (= (str.at s (+ i 1)) ""-"")))))

6. (str.in.re s (re.++ (re.* (re.union (re.range ""0"" ""9"") (str.to.re ""-"")) (re.opt (str.to.re ""-"")) (re.* (re.union (re.range ""0"" ""9"") (str.to.re ""-""))) (re.opt (str.to.re ""-"")) (re.* (re.union (re.range ""0"" ""9"") (str.to.re ""-""))) (re.opt (str.to.re ""-"")) (re.* (re.union (re.range ""0"" ""9"") (str.to.re ""-"")))))","1. (exists ((i Int)) (and (>= i 0) (< i (str.len s)) (not (or (and (>= (str.to_code (str.at s i)) 48) (<= (str.to_code (str.at s i)) 57)) (= (str.at s i) ""X"") (= (str.at s i) ""-"")))))

2. (not (or (str.in_re (str.at s (- (str.len s) 1)) (re.range ""0"" ""9"")) (= (str.at s (- (str.len s) 1)) ""X"")))

3. (or (< (str.len (str.replace_all s ""-"" """")) 10) (> (str.len (str.replace_all s ""-"" """")) 10))

4. (= (str.at s 0) ""-"")

5. (str.contains s ""--"")

6. (> (str.len (str.replace_all s ""-"" """")) (- (str.len s) 3))","['def constraint1(s: str) -> bool:\n    \'\'\' Check if the ISBN shall only contain numbers (0-9), the letter X, or hyphens.\'\'\'\n    allowed_chars = set(""0123456789X-"")\n    return all(char in allowed_chars for char in s)', ""def constraint2(s: str) -> bool:\n    ''' \n    Check if the last character of the ISBN is either a number (0-9) or the letter X.\n    \n    Args:\n    s (str): The ISBN string to check.\n    \n    Returns:\n    bool: True if the last character is valid, False otherwise.\n    '''\n    if not s:  # Check if the string is empty\n        return False\n    \n    last_char = s[-1]  # Get the last character of the string\n    \n    # Check if the last character is a digit or 'X'\n    return last_char.isdigit() or last_char.upper() == 'X'"", ""def constraint3(s: str) -> bool:\n    # Remove hyphens from the string\n    s_cleaned = s.replace('-', '')\n    \n    # Check if the cleaned string has exactly 10 characters\n    return len(s_cleaned) == 10"", ""def constraint4(s: str) -> bool:\n    '''Check if the ISBN shall not start with a hyphen.'''\n    return not s.startswith('-')"", ""def constraint5(s: str) -> bool:\n    ''' Check if hyphens shall not occur consecutively in the ISBN.'''\n    for i in range(len(s) - 1):\n        if s[i] == '-' and s[i + 1] == '-':\n            return False\n    return True"", ""def constraint6(s: str) -> bool:\n    ''' Check if The ISBN shall contain at most 3 hyphens.'''\n    return s.count('-') <= 3""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the ISBN contains at least one character that is neither a number (0-9), nor the letter X, nor a hyphen.'''\n    for char in s:\n        if not (char.isdigit() or char == 'X' or char == '-'):\n            return True\n    return False"", ""def constraint2(s: str) -> bool:\n    ''' Check if the last character of the ISBN is neither a number (0-9) nor the letter X.'''\n    if not s:  # Check if the string is empty\n        return False\n    \n    last_char = s[-1]  # Get the last character of the string\n    \n    # Check if the last character is neither a digit nor 'X'\n    return not (last_char.isdigit() or last_char.upper() == 'X')"", ""def constraint3(s: str) -> bool:\n    # Remove hyphens from the string\n    cleaned_s = s.replace('-', '')\n    \n    # Check if the length of the cleaned string is not equal to 10\n    return len(cleaned_s) != 10"", ""def constraint4(s: str) -> bool:\n    '''Check if the string starts with a hyphen.'''\n    return s.startswith('-')"", ""def constraint5(s: str) -> bool:\n    ''' Check if the ISBN contains two consecutive hyphens.'''\n    return '--' in s"", ""def constraint6(s: str) -> bool:\n    ''' Check if The ISBN shall contain more than 3 hyphens.'''\n    return s.count('-') > 3""]","[True, True, False, True, True, False]","[True, True, False, True, True, False]","[True, True, True, True, True, True]","[True, True, True, True, True, True]"
08,Expression,"1. The arithmetic expression shall only contain numbers (0-9) and arithmetic operators (+, -, *, /).

2. The arithmetic operators (+, -, *, /) in the arithmetic expression shall not appear consecutively.

3. Except for the minus sign (-), every operator (+, *, /) in the arithmetic expression shall have a number before and after it.

4. The arithmetic expression shall not start with operators from the set {+, *, /}.","1. The arithmetic expression shall contain at least one character that is neither a number (0-9), nor an arithmetic operator (+, -, *, /).

2. The arithmetic expression shall contain consecutive arithmetic operators (+, -, *, /).

3. The arithmetic expression shall contain an operator from the set {+, *, /} that either does not have a number immediately before it or does not have a number immediately after it.

4. The arithmetic expression shall start with one of the operators in the set {+, *, /}.","1. (str.in.re s (re.+ (re.union (re.range ""0"" ""9"") (str.to.re ""+"") (str.to.re ""-"") (str.to.re ""*"") (str.to.re ""/""))))

2. (forall ((i Int)) (=> (and (>= i 0) (< i (- (seq.len s) 1))) (not (and (or (= (seq.nth s i) ""+"") (= (seq.nth s i) ""-"") (= (seq.nth s i) ""*"") (= (seq.nth s i) ""/"")) (or (= (seq.nth s (+ i 1)) ""+"") (= (seq.nth s (+ i 1)) ""-"") (= (seq.nth s (+ i 1)) ""*"") (= (seq.nth s (+ i 1)) ""/""))))

3. (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (=> (or (= (str.at s i) ""+"") (= (str.at s i) ""*"") (= (str.at s i) ""/"")) (and (not (= (str.at s (- i 1)) "" "")) (not (= (str.at s (+ i 1)) "" ""))))))

4. (and (not (= (str.at s 0) ""+"")) (not (= (str.at s 0) ""*"")) (not (= (str.at s 0) ""/"")))","1. (str.in.re s (re.++ (re.* re.allchar) (re.union (re.diff re.allchar (re.range ""0"" ""9"")) (re.diff re.allchar (re.union (str.to.re ""+"") (str.to.re ""-"") (str.to.re ""*"") (str.to.re ""/"")))) (re.* re.allchar)))

2. (or (str.contains s ""++"") (str.contains s ""--"") (str.contains s ""**"") (str.contains s ""//"") (str.contains s ""+-"") (str.contains s ""-+"") (str.contains s ""+*"") (str.contains s ""*+"") (str.contains s ""+/"") (str.contains s ""/+"") (str.contains s ""-*"") (str.contains s ""*-"") (str.contains s ""-/"") (str.contains s ""/-"") (str.contains s ""*/"") (str.contains s ""/*""))

3. (exssts ((s Int)) (and (>= s 0) (< s (seq.len s)) (or (and (ss_operator (seq.nth s s)) (or (not (ss_number (seq.nth s (- s 1)))) (not (ss_number (seq.nth s (+ s 1))))))))

4. (or (= (str.at s 0) ""+"") (= (str.at s 0) ""*"") (= (str.at s 0) ""/""))","[""def constraint1(s: str) -> bool:\n    # Define a regular expression pattern that matches only numbers and arithmetic operators\n    pattern = r'^[0-9+\\-*/ ]+$'\n    \n    # Use the fullmatch method to check if the entire string matches the pattern\n    if re.fullmatch(pattern, s):\n        return True\n    else:\n        return False"", ""def constraint2(s: str) -> bool:\n    # Define the set of arithmetic operators\n    operators = {'+', '-', '*', '/'}\n    \n    # Iterate through the string\n    for i in range(len(s) - 1):\n        # Check if both current and next characters are operators\n        if s[i] in operators and s[i+1] in operators:\n            return False\n    \n    # If no consecutive operators found, return True\n    return True"", ""def constraint3(s: str) -> bool:\n    # Iterate through each character in the string\n    for i, char in enumerate(s):\n        if char in {'+', '*', '/'}:\n            # Check if the character before and after the operator is a digit\n            if i == 0 or i == len(s) - 1:\n                return False  # Operator at the start or end\n            if not (s[i-1].isdigit() and s[i+1].isdigit()):\n                return False  # No digit before or after the operator\n        elif char == '-':\n            # Handle the minus sign carefully\n            if i == 0:\n                # If it's the first character, it's a unary minus (valid)\n                continue\n            elif s[i-1] in {'+', '-', '*', '/'}:\n                # If the previous character is an operator, it's a unary minus (valid)\n                continue\n            elif not s[i+1].isdigit():\n                # If it's a binary minus, the next character must be a digit\n                return False\n    return True"", ""def constraint4(s: str) -> bool:\n    ''' \n    Check if the arithmetic expression does not start with operators from the set {+, *, /}.\n    \n    Args:\n    s (str): The arithmetic expression to check.\n    \n    Returns:\n    bool: True if the expression does not start with +, *, or /; False otherwise.\n    '''\n    # Remove any leading whitespace\n    s = s.lstrip()\n    \n    # Check if the first character is one of the forbidden operators\n    if s and s[0] in {'+', '*', '/'}:\n        return False\n    return True""]","[""def constraint1(s: str) -> bool:\n    ''' \n    Check if the arithmetic expression contains at least one character \n    that is neither a number (0-9) nor an arithmetic operator (+, -, *, /).\n    '''\n    for char in s:\n        if not (char.isdigit() or char in {'+', '-', '*', '/'}):\n            return True\n    return False"", ""def constraint2(s: str) -> bool:\n    ''' \n    Check if the arithmetic expression contains consecutive arithmetic operators (+, -, *, /).\n    \n    Args:\n    s (str): The arithmetic expression to check.\n    \n    Returns:\n    bool: True if the expression contains consecutive arithmetic operators, False otherwise.\n    '''\n    operators = {'+', '-', '*', '/'}\n    \n    for i in range(len(s) - 1):\n        if s[i] in operators and s[i+1] in operators:\n            return True\n    return False"", ""def constraint3(s: str) -> bool:\n    operators = {'+', '*', '/'}\n    for i, char in enumerate(s):\n        if char in operators:\n            # Check if the character before the operator is a digit\n            before_is_digit = i > 0 and s[i-1].isdigit()\n            # Check if the character after the operator is a digit\n            after_is_digit = i < len(s) - 1 and s[i+1].isdigit()\n            \n            # If either before or after is not a digit, return True\n            if not before_is_digit or not after_is_digit:\n                return True\n    return False"", ""def constraint4(s: str) -> bool:\n    '''Check if the arithmetic expression starts with one of the operators in the set {+, *, /}.'''\n    # Check if the string is not empty and the first character is one of the operators\n    return len(s) > 0 and s[0] in {'+', '*', '/'}""]","[True, False, True, True]","[True, True, False, True]","[True, True, True, True]","[True, True, True, True]"
09,Palindrome,"1. The palindrome shall be at least 3 characters long.

2. The palindrome shall be identical to its reverse.","1. The palindrome shall be at most 2 characters long.

2. The palindrome shall not be identical to its reverse.","1. (>= (str.len s) 3)

2. (= s (str.reverse s))","1. (<= (str.len s) 2)

2. (not (= s (str.reverse s)))","[""def constraint1(s: str) -> bool:\n    ''' Check if the string is a palindrome and at least 3 characters long.'''\n    # Check if the string is at least 3 characters long\n    if len(s) < 3:\n        return False\n    \n    # Check if the string is a palindrome\n    return s == s[::-1]"", ""def constraint2(s: str) -> bool:\n    ''' Check if the string is a palindrome. A palindrome is identical to its reverse.'''\n    return s == s[::-1]""]","[""def constraint1(s: str) -> bool:\n    ''' Check if the palindrome is at most 2 characters long.'''\n    # Check if the string is a palindrome and its length is at most 2\n    return s == s[::-1] and len(s) <= 2"", ""def constraint2(s: str) -> bool:\n    '''Check if the string is a palindrome.'''\n    return s == s[::-1]""]","[True, False]","[True, False]","[True, True]","[True, True]"
10,Parentheses,"1. The parentheses string shall be at least 10 characters long.

2. The parentheses string shall only contains ( and ) characters.

3. The parenthesis string shall contain an equal number of ( characters and ) characters.

4. When scanning from left to right on the parentheses string, at no point shall the count of ) characters exceed the count of ( characters.","1. The parentheses string shall be at most 9 characters long.

2. The parentheses string shall contain at least one character that is neither ( nor ).

3. The parenthesis string shall not contain an equal number of ( characters and ) characters.

4. There shall exist at least one position in a parentheses string such that, when scanning from left to right up to that position, the count of ) characters exceeds the count of ( characters.","1. (>= (str.len s) 10)

2. (str.in.re s (re.* (re.union (str.to.re ""("") (str.to.re "")""))))

3. (= (str.len (str.replace_all s ""("" """")) (str.len (str.replace_all s "")"" """")))

4. (forall ((i Int)) (=> (and (>= i 0) (< i (str.len s))) (>= (str.count s ""("" 0 i) (str.count s "")"" 0 i))))","1. (<= (str.len s) 9)

2. (exists ((i Int)) (and (>= i 0) (< i (str.len s)) (not (or (= (str.at s i) ""("") (= (str.at s i) "")""))))

3. (not (= (str.len (str.replace_all s ""("" """")) (str.len (str.replace_all s "")"" """"))))

4. (exists ((i Int)) (and (>= i 0) (< i (str.len s)) (> (str.count s "")"" 0 i) (str.count s ""("" 0 i))))","[""def constraint1(s: str) -> bool:\n    '''Check if the parentheses string shall be at least 10 characters long.'''\n    return len(s) >= 10"", ""def constraint2(s: str) -> bool:\n    ''' Check if the parentheses string shall only contains ( and ) characters.'''\n    for char in s:\n        if char not in '()':\n            return False\n    return True"", ""def constraint3(s: str) -> bool:\n    ''' \n    Check if the parenthesis string contains an equal number of '(' and ')' characters.\n    \n    Args:\n    s (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the number of '(' and ')' characters are equal, False otherwise.\n    '''\n    count = 0\n    \n    for char in s:\n        if char == '(':\n            count += 1\n        elif char == ')':\n            count -= 1\n    \n    return count == 0"", ""def constraint4(s: str) -> bool:\n    ''' \n    Check if when scanning from left to right on the parentheses string, \n    at no point shall the count of ')' characters exceed the count of '(' characters.\n    '''\n    balance = 0  # Tracks the difference between '(' and ')'\n    \n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # If balance goes negative, it means ')' exceeds '(' at some point\n        if balance < 0:\n            return False\n    \n    # If balance is non-negative throughout, the condition is satisfied\n    return True""]","[""def constraint1(s: str) -> bool:\n    '''Check if the parentheses string is at most 9 characters long.'''\n    return len(s) <= 9"", ""def constraint2(s: str) -> bool:\n    ''' \n    Check if the parentheses string contains at least one character that is neither ( nor ).\n    \n    Args:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string contains at least one character that is neither ( nor ), False otherwise.\n    '''\n    for char in s:\n        if char != '(' and char != ')':\n            return True\n    return False"", ""def constraint3(s: str) -> bool:\n    ''' \n    Check if the number of '(' characters is not equal to the number of ')' characters in the string.\n    \n    Args:\n        s (str): The input string containing parentheses.\n        \n    Returns:\n        bool: True if the counts of '(' and ')' are not equal, False otherwise.\n    '''\n    return s.count('(') != s.count(')')"", ""def constraint4(s: str) -> bool:\n    ''' \n    Check if there exists at least one position in a parentheses string such that, \n    when scanning from left to right up to that position, the count of ')' characters \n    exceeds the count of '(' characters.\n    '''\n    count_open = 0  # Count of '('\n    count_close = 0  # Count of ')'\n    \n    for char in s:\n        if char == '(':\n            count_open += 1\n        elif char == ')':\n            count_close += 1\n        \n        # If at any point, ')' count exceeds '(' count, return True\n        if count_close > count_open:\n            return True\n    \n    # If we finish the loop without finding such a position, return False\n    return False""]","[True, True, False, False]","[True, False, False, False]","[True, True, True, True]","[True, True, True, True]"
11,DNA,"1. The DNA sequence shall only contain letters A, T, C and G.

2. The length of The DNA sequence shall be at least 10.

3. The length of The DNA sequence shall be a multiple of three.

4. The DNA sequence shall start with ATG.

5. The DNA sequence shall end with either TAA, or TAG, or TGA.","1. The DNA sequence shall contain at least one letter that is neither A, nor T, nor C, nor G.

2. The length of the DNA sequence shall be at most 9.

3. The length of the DNA sequence shall not a multiple of three.

4. The DNA sequence shall not start with ATG.

5. The DNA sequence shall not end with TAA, nor with TAG, nor with TGA.","1. (str.in.re s (re.++ (re.* (re.union (str.to.re ""A"") (str.to.re ""T"") (str.to.re ""C"") (str.to.re ""G"")))))

2. (>= (str.len s) 10)

3. (= (mod (str.len s) 3) 0)

4. (= (str.substr s 0 3) ""ATG"")

5. (or (= (str.substr s (- (str.len s) 3) 3) ""TAA"") (= (str.substr s (- (str.len s) 3) 3) ""TAG"") (= (str.substr s (- (str.len s) 3) 3) ""TGA""))","1. (assert (str.in_re s (re.++ (re.* (re.union (str.to_re ""A"") (str.to_re ""T"") (str.to_re ""C"") (str.to_re ""G""))) (re.union (re.comp (re.union (str.to_re ""A"") (str.to_re ""T"") (str.to_re ""C"") (str.to_re ""G""))) re.allchar) (re.* re.allchar))))

2. (<= (str.len s) 9)

3. (not (= (mod (str.len s) 3) 0))

4. (not (str.prefixof ""ATG"" s))

5. (and (not (str.suffixof ""TAA"" s)) (not (str.suffixof ""TAG"" s)) (not (str.suffixof ""TGA"" s)))","[""def constraint1(s: str) -> bool:\n    ''' Check if the DNA sequence shall only contain letters A, T, C and G.'''\n    valid_nucleotides = {'A', 'T', 'C', 'G'}\n    \n    # Check if all characters in the string are valid nucleotides\n    return all(char.upper() in valid_nucleotides for char in s)"", ""def constraint2(s: str) -> bool:\n    ''' Check if the length of the DNA sequence is at least 10.'''\n    return len(s) >= 10"", ""def constraint3(s: str) -> bool:\n    '''Check if the length of the DNA sequence is a multiple of three.'''\n    return len(s) % 3 == 0"", 'def constraint4(s: str) -> bool:\n    \'\'\' Check if the DNA sequence starts with ATG.\'\'\'\n    return s.startswith(""ATG"")', 'def constraint5(s: str) -> bool:\n    \'\'\' Check if the DNA sequence ends with either TAA, or TAG, or TGA.\'\'\'\n    # Define the stop codons\n    stop_codons = [""TAA"", ""TAG"", ""TGA""]\n    \n    # Check if the last three characters of the string are in the stop_codons list\n    return s[-3:].upper() in stop_codons']","[""def constraint1(s: str) -> bool:\n    ''' Check if the DNA sequence contains at least one letter that is neither A, nor T, nor C, nor G.'''\n    # Define the set of valid DNA nucleotides\n    valid_nucleotides = {'A', 'T', 'C', 'G'}\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If a character is not in the set of valid nucleotides, return True\n        if char not in valid_nucleotides:\n            return True\n    \n    # If all characters are valid, return False\n    return False"", ""def constraint2(s: str) -> bool:\n    ''' Check if the length of the DNA sequence is at most 9.'''\n    return len(s) <= 9"", ""def constraint3(s: str) -> bool:\n    '''Check if the length of the DNA sequence is not a multiple of three.'''\n    return len(s) % 3 != 0"", 'def constraint4(s: str) -> bool:\n    \'\'\' Check if the DNA sequence shall not start with ATG.\'\'\'\n    return not s.startswith(""ATG"")', ""def constraint5(s: str) -> bool:\n    ''' \n    Check if the DNA sequence does not end with TAA, TAG, or TGA.\n    \n    Args:\n    s (str): The DNA sequence to check.\n    \n    Returns:\n    bool: True if the sequence does not end with TAA, TAG, or TGA; False otherwise.\n    '''\n    # Define the stop codons\n    stop_codons = ['TAA', 'TAG', 'TGA']\n    \n    # Check if the sequence ends with any of the stop codons\n    for codon in stop_codons:\n        if s.endswith(codon):\n            return False\n    \n    # If none of the stop codons are found at the end, return True\n    return True""]","[True, True, True, True, True]","[False, True, True, True, True]","[True, True, True, True, True]","[True, True, True, True, True]"
12,Absolute_Path,"1. The absolute path shall start with the root directory ""/"".

2. The absolute path shall not contain any spaces.

3. The absolute path shall not end with ""/"".

4. The absolute path shall not contain consecutive ""/"" characters.","1. The absolute path shall not start with the root directory ""/"".

2. The absolute path shall contain at least one space.

3. The absolute path shall end with ""/"".

4. The absolute path shall contain consecutive ""/"" characters.","1. (= (str.at s 0) ""/"")

2. (not (str.contains s "" ""))

3. (not (= (str.at s (- (str.len s) 1)) ""/""))

4. (not (str.in.re s (re.++ (re.* re.allchar) (str.to.re ""//"") (re.* re.allchar))))","1. (not (= (str.at s 0) ""/""))

2. (str.contains s "" "")

3. (str.suffixof ""/"" s)

4. (str.in.re s (re.++ (re.* re.allchar) (str.to.re ""//"") (re.* re.allchar)))","['def constraint1(s: str) -> bool:\n    \'\'\' Check if the absolute path starts with the root directory ""/"".\'\'\'\n    return s.startswith(\'/\')', ""def constraint2(s: str) -> bool:\n    ''' Check if the absolute path contains any spaces.'''\n    return ' ' not in s"", 'def constraint3(s: str) -> bool:\n    \'\'\'Check if the absolute path does not end with ""/"".\'\'\'\n    return not s.endswith(\'/\')', 'def constraint4(s: str) -> bool:\n    \'\'\' Check if the absolute path does not contain consecutive ""/"" characters.\'\'\'\n    return \'//\' not in s']","['def constraint1(s: str) -> bool:\n    \'\'\' Check if the absolute path does not start with the root directory ""/"".\'\'\'\n    return not s.startswith(\'/\')', ""def constraint2(s: str) -> bool:\n    ''' Check if the absolute path contains at least one space.'''\n    return ' ' in s"", 'def constraint3(s: str) -> bool:\n    \'\'\' Check if the absolute path ends with ""/"".\'\'\'\n    return s.endswith(\'/\')', 'def constraint4(s: str) -> bool:\n    \'\'\' Check if the absolute path contains consecutive ""/"" characters.\'\'\'\n    return \'//\' in s']","[True, True, True, True]","[True, True, True, True]","[True, True, True, True]","[True, True, True, True]"
